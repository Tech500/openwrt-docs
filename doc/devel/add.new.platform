<!DOCTYPE html>
<html lang="en" dir="ltr" class="no-js">
<head>
    <meta charset="utf-8" />
    <title>Adding new platform support [OpenWrt Wiki]</title>
    <script>(function(H){H.className=H.className.replace(/\bno-js\b/,'js')})(document.documentElement)</script>
    <meta name="generator" content="DokuWiki"/>
<meta name="robots" content="index,follow"/>
<meta name="keywords" content="doc,devel,add.new.platform"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../lib/exe/opensearch.php" title="OpenWrt Wiki"/>
<link rel="start" href="../../index.html"/>
<link rel="contents" href="add.new.platform?do=index" title="Sitemap"/>
<link rel="alternate" type="application/rss+xml" title="Recent changes" href="../../feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current namespace" href="../../feed.php?mode=list&amp;ns=doc:devel"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="../../_export/xhtml/doc/devel/add.new.platform"/>
<link rel="alternate" type="text/plain" title="Wiki Markup" href="../../_export/raw/doc/devel/add.new.platform"/>
<link rel="canonical" href="add.new.platform"/>
<link rel="stylesheet" type="text/css" href="../../lib/exe/css.php?t=openwrt&amp;tseed=6f44f363dc87908d905dc56ff3acbfc4"/>
<script type="text/javascript">/*<![CDATA[*/var NS='doc:devel';var JSINFO = {"id":"doc:devel:add.new.platform","namespace":"doc:devel"};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="../../lib/exe/js.php?tseed=6f44f363dc87908d905dc56ff3acbfc4"></script>
<script type="text/javascript" charset="utf-8">/*<![CDATA[*/jQuery(function(){
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1432265700 166.182.3.62';
			document.forms[i].appendChild(myElement);
		}
	}
});
/*!]]>*/</script>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="shortcut icon" href="../../lib/tpl/openwrt/images/favicon.ico" />
<link rel="apple-touch-icon" href="../../lib/tpl/openwrt/images/apple-touch-icon.png" />
    </head>

<body>
    <!--[if lte IE 7 ]><div id="IE7"><![endif]--><!--[if IE 8 ]><div id="IE8"><![endif]-->
    <div id="dokuwiki__site"><div id="dokuwiki__top" class="site dokuwiki mode_show tpl_openwrt     ">

        
<!-- ********** HEADER ********** -->
<div id="dokuwiki__header"><div class="pad group">

    
    <div class="headings group">
        <ul class="a11y skip">
            <li><a href="add.new.platform#dokuwiki__content">skip to content</a></li>
        </ul>

        <h1><a href="../../start"  accesskey="h" title="[H]"><img src="../../lib/tpl/openwrt/images/logo.png" width="386" height="98" alt="" /> <span>OpenWrt Wiki</span></a></h1>
            </div>

    <div class="tools group">
        <!-- USER TOOLS -->
                    <div id="dokuwiki__usertools">
                <h3 class="a11y">User Tools</h3>
                <ul>
                    <li><a href="add.new.platform?do=register"  class="action register" rel="nofollow" title="Register">Register</a></li><li><a href="add.new.platform?do=login&amp;sectok=382740b13d95f946eed36caa57076b4a"  class="action login" rel="nofollow" title="Login">Login</a></li>                </ul>
            </div>
        
        <!-- SITE TOOLS -->
        <div id="dokuwiki__sitetools">
            <h3 class="a11y">Site Tools</h3>
            <form action="../../start" accept-charset="utf-8" class="search" id="dw__search" method="get" role="search"><div class="no"><input type="hidden" name="do" value="search" /><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]" /><input type="submit" value="Search" class="button" title="Search" /><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>            <div class="mobileTools">
                <form action="../../doku.php" method="get" accept-charset="utf-8"><div class="no"><input type="hidden" name="id" value="doc:devel:add.new.platform" /><select name="do" class="edit quickselect" title="Tools"><option value="">Tools</option><optgroup label="Page Tools"><option value="edit">Show pagesource</option><option value="revisions">Old revisions</option><option value="backlink">Backlinks</option></optgroup><optgroup label="Site Tools"><option value="recent">Recent changes</option><option value="media">Media Manager</option><option value="index">Sitemap</option></optgroup><optgroup label="User Tools"><option value="login">Login</option><option value="register">Register</option></optgroup></select><input type="submit" value="&gt;" /></div></form>            </div>
            <ul>
                <li><a href="add.new.platform?do=recent"  class="action recent" accesskey="r" rel="nofollow" title="Recent changes [R]">Recent changes</a></li><li><a href="add.new.platform?do=media&amp;ns=doc%253Adevel"  class="action media" rel="nofollow" title="Media Manager">Media Manager</a></li><li><a href="add.new.platform?do=index"  class="action index" accesskey="x" rel="nofollow" title="Sitemap [X]">Sitemap</a></li>            </ul>
        </div>

    </div>

    <!-- BREADCRUMBS -->
            <div class="breadcrumbs">
                            <div class="youarehere"><span class="bchead">You are here: </span><span class="home"><bdi><a href="../../start" class="wikilink1" title="start">OpenWrt Wiki</a></bdi></span> » <bdi><a href="../start" class="wikilink1" title="doc:start">Documentation</a></bdi> » <bdi><a href="start" class="wikilink1" title="doc:devel:start">Developing</a></bdi> » <bdi><span class="curid"><a href="add.new.platform" class="wikilink1" title="doc:devel:add.new.platform">Adding new platform support</a></span></bdi></div>
                                    <div class="plugin_multilingual">
        <ul>
          <li>
            <div class="li">
              <div class="flag_not_exists">
                <a href="http://wiki.openwrt.org/cz/doc/devel/add.new.platform" class="media" title="cz:doc:devel:add.new.platform"><img src="../../lib/exe/fetch.php?cache=&amp;tok=aff589&amp;media=http%253A%252F%252Fwiki.openwrt.org%252Flib%252Fplugins%252Fmultilingual%252Fflags%252Fcz.gif" class="media" title="Čeština (Czech)" alt="Čeština (Czech)" /></a>
              </div>
            </div>
          </li>
          <li>
            <div class="li">
              <div class="flag_not_exists">
                <a href="http://wiki.openwrt.org/de/doc/devel/add.new.platform" class="media" title="de:doc:devel:add.new.platform"><img src="../../lib/exe/fetch.php?cache=&amp;tok=e24010&amp;media=http%253A%252F%252Fwiki.openwrt.org%252Flib%252Fplugins%252Fmultilingual%252Fflags%252Fde.gif" class="media" title="Deutsch (German)" alt="Deutsch (German)" /></a>
              </div>
            </div>
          </li>
          <li>
            <div class="li">
              <span class="curid"><a href="add.new.platform" class="media" title="doc:devel:add.new.platform"><img src="../../lib/exe/fetch.php?cache=&amp;tok=2a37ae&amp;media=http%253A%252F%252Fwiki.openwrt.org%252Flib%252Fplugins%252Fmultilingual%252Fflags%252Fgb.gif" class="media" title="English" alt="English" /></a></span>
            </div>
          </li>
          <li>
            <div class="li">
              <div class="flag_not_exists">
                <a href="http://wiki.openwrt.org/es/doc/devel/add.new.platform" class="media" title="es:doc:devel:add.new.platform"><img src="../../lib/exe/fetch.php?cache=&amp;tok=46c004&amp;media=http%253A%252F%252Fwiki.openwrt.org%252Flib%252Fplugins%252Fmultilingual%252Fflags%252Fmx.gif" class="media" title="Español (Spanish, Mexico)" alt="Español (Spanish, Mexico)" /></a>
              </div>
            </div>
          </li>
          <li>
            <div class="li">
              <div class="flag_not_exists">
                <a href="http://wiki.openwrt.org/fr/doc/devel/add.new.platform" class="media" title="fr:doc:devel:add.new.platform"><img src="../../lib/exe/fetch.php?cache=&amp;tok=a5beba&amp;media=http%253A%252F%252Fwiki.openwrt.org%252Flib%252Fplugins%252Fmultilingual%252Fflags%252Ffr.gif" class="media" title="Français (French)" alt="Français (French)" /></a>
              </div>
            </div>
          </li>
          <li>
            <div class="li">
              <div class="flag_not_exists">
                <a href="http://wiki.openwrt.org/hu/doc/devel/add.new.platform" class="media" title="hu:doc:devel:add.new.platform"><img src="../../lib/exe/fetch.php?cache=&amp;tok=6b5470&amp;media=http%253A%252F%252Fwiki.openwrt.org%252Flib%252Fplugins%252Fmultilingual%252Fflags%252Fhu.gif" class="media" title="Magyar (Hungarian)" alt="Magyar (Hungarian)" /></a>
              </div>
            </div>
          </li>
          <li>
            <div class="li">
              <div class="flag_not_exists">
                <a href="http://wiki.openwrt.org/jp/doc/devel/add.new.platform" class="media" title="jp:doc:devel:add.new.platform"><img src="../../lib/exe/fetch.php?cache=&amp;tok=f999fc&amp;media=http%253A%252F%252Fwiki.openwrt.org%252Flib%252Fplugins%252Fmultilingual%252Fflags%252Fjp.gif" class="media" title="日本語 (Japanese)" alt="日本語 (Japanese)" /></a>
              </div>
            </div>
          </li>
          <li>
            <div class="li">
              <div class="flag_not_exists">
                <a href="http://wiki.openwrt.org/pl/doc/devel/add.new.platform" class="media" title="pl:doc:devel:add.new.platform"><img src="../../lib/exe/fetch.php?cache=&amp;tok=c805c0&amp;media=http%253A%252F%252Fwiki.openwrt.org%252Flib%252Fplugins%252Fmultilingual%252Fflags%252Fpl.gif" class="media" title="Poliski (Polish)" alt="Poliski (Polish)" /></a>
              </div>
            </div>
          </li>
          <li>
            <div class="li">
              <div class="flag_not_exists">
                <a href="http://wiki.openwrt.org/pt-br/doc/devel/add.new.platform" class="media" title="pt-br:doc:devel:add.new.platform"><img src="../../lib/exe/fetch.php?cache=&amp;tok=13127d&amp;media=http%253A%252F%252Fwiki.openwrt.org%252Flib%252Fplugins%252Fmultilingual%252Fflags%252Fbr.gif" class="media" title="Português brasileiro (Portuguese, Brasil)" alt="Português brasileiro (Portuguese, Brasil)" /></a>
              </div>
            </div>
          </li>
          <li>
            <div class="li">
              <div class="flag_not_exists">
                <a href="http://wiki.openwrt.org/ru/doc/devel/add.new.platform" class="media" title="ru:doc:devel:add.new.platform"><img src="../../lib/exe/fetch.php?cache=&amp;tok=66ab5e&amp;media=http%253A%252F%252Fwiki.openwrt.org%252Flib%252Fplugins%252Fmultilingual%252Fflags%252Fru.gif" class="media" title="Русский (Russsian)" alt="Русский (Russsian)" /></a>
              </div>
            </div>
          </li>
          <li>
            <div class="li">
              <div class="flag_not_exists">
                <a href="http://wiki.openwrt.org/tr/doc/devel/add.new.platform" class="media" title="tr:doc:devel:add.new.platform"><img src="../../lib/exe/fetch.php?cache=&amp;tok=f4beed&amp;media=http%253A%252F%252Fwiki.openwrt.org%252Flib%252Fplugins%252Fmultilingual%252Fflags%252Ftr.gif" class="media" title="Tϋrkçe (Turkish)" alt="Tϋrkçe (Turkish)" /></a>
              </div>
            </div>
          </li>
          <li>
            <div class="li">
              <div class="flag_not_exists">
                <a href="http://wiki.openwrt.org/zh-cn/doc/devel/add.new.platform" class="media" title="zh-cn:doc:devel:add.new.platform"><img src="../../lib/exe/fetch.php?cache=&amp;tok=93625a&amp;media=http%253A%252F%252Fwiki.openwrt.org%252Flib%252Fplugins%252Fmultilingual%252Fflags%252Fzh-cn.gif" class="media" title="官話/官话 (Chinese)" alt="官話/官话 (Chinese)" /></a>
              </div>
            </div>
          </li>
          <li>
            <div class="li">
              <div class="flag_not_exists">
                <a href="http://wiki.openwrt.org/zh-tw/doc/devel/add.new.platform" class="media" title="zh-tw:doc:devel:add.new.platform"><img src="../../lib/exe/fetch.php?cache=&amp;tok=b56198&amp;media=http%253A%252F%252Fwiki.openwrt.org%252Flib%252Fplugins%252Fmultilingual%252Fflags%252Fzh-tw.gif" class="media" title="臺灣華語 (Taiwanese)" alt="臺灣華語 (Taiwanese)" /></a>
              </div>
            </div>
          </li>
        </ul>
      </div>
        </div>
    
    
    <hr class="a11y" />
</div></div><!-- /header -->

        <div class="wrapper group">

            
            <!-- ********** CONTENT ********** -->
            <div id="dokuwiki__content"><div class="pad group">

                <div class="pageId"><span>doc:devel:add.new.platform</span></div>

                <div class="page group">
                                                            <!-- wikipage start -->
                    <!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="add.new.platform#which_operating_system_does_this_device_run">Which Operating System does this device run?</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="add.new.platform#operating_system_fingerprinting_and_port_scanning">Operating System fingerprinting and port scanning</a></div></li>
<li class="level2"><div class="li"><a href="add.new.platform#wireless_communications_fingerprinting">Wireless Communications Fingerprinting</a></div></li>
<li class="level2"><div class="li"><a href="add.new.platform#web_server_security_exploits">Web server security exploits</a></div></li>
<li class="level2"><div class="li"><a href="add.new.platform#native_telnetssh_access">Native Telnet/SSH access</a></div></li>
<li class="level2"><div class="li"><a href="add.new.platform#analyzing_a_binary_firmware_image">Analyzing a binary firmware image</a></div></li>
<li class="level2"><div class="li"><a href="add.new.platform#amount_of_flash_memory">Amount of flash memory</a></div></li>
<li class="level2"><div class="li"><a href="add.new.platform#plugging_a_serial_port">Plugging a serial port</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="add.new.platform#finding_and_using_the_manufacturer_sdk">Finding and using the manufacturer SDK</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="add.new.platform#gpl_violations">GPL violations</a></div></li>
<li class="level2"><div class="li"><a href="add.new.platform#using_the_sdk">Using the SDK</a></div></li>
<li class="level2"><div class="li"><a href="add.new.platform#creating_a_hardware_specific_kernel_patch">Creating a hardware specific kernel patch</a></div></li>
<li class="level2"><div class="li"><a href="add.new.platform#using_the_device_bootloader">Using the device bootloader</a></div></li>
<li class="level2"><div class="li"><a href="add.new.platform#making_binary_drivers_work">Making binary drivers work</a></div></li>
<li class="level2"><div class="li"><a href="add.new.platform#understanding_the_firmware_format">Understanding the firmware format</a></div></li>
<li class="level2"><div class="li"><a href="add.new.platform#writing_a_flash_map_driver">Writing a flash map driver</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="adding_new_platform_support">Adding new platform support</h1>
<div class="level1">

<p>
You can find a list of all currently supported <a href="https://dev.openwrt.org/wiki/platforms" class="urlextern" title="https://dev.openwrt.org/wiki/platforms"  rel="nofollow">https://dev.openwrt.org/wiki/platforms</a>. Maybe there is no need to add a completely new platform, but only a new device, see →<a href="add.new.device" class="wikilink1" title="doc:devel:add.new.device">add.new.device</a>.
</p>

<p>
Linux is now one of the most widespread operating system for embedded devices due to its openess as well as the wide variety of platforms it can run on.
Many manufacturer actually use it in firmware you can find on many devices: DVB-T decoders, routers, print servers, DVD players …
Most of the time the stock firmware is not really open to the consumer, even if it uses open source software.
</p>

<p>
You might be interested in running a Linux based firmware for your router for various reasons: extending the use of a network protocol (such as IPv6),
having new features, new piece of software inside, or for security reasons. A fully open-source firmware is de-facto needed for such applications,
since you want to be free to use this or that version of a particular reason, be able to correct a particular bug. Few manufacturers do ship their
routers with a Sample Development Kit, that would allow you to create your own and custom firmware and most of the time, when they do, you will
most likely not be able to complete the firmware creation process.
</p>

<p>
This is one of the reasons why OpenWrt and other firmware exists: providing a version independent, and tools independent firmware, that can be run
on various platforms, known to be running Linux originally.
</p>

</div>

<h2 class="sectionedit2" id="which_operating_system_does_this_device_run">Which Operating System does this device run?</h2>
<div class="level2">

<p>
There is a lot of methods to ensure your device is running Linux. Some of them do need your router to be unscrewed and open, some can be done by
probing the device using its external network interfaces.
</p>

</div>

<h3 class="sectionedit3" id="operating_system_fingerprinting_and_port_scanning">Operating System fingerprinting and port scanning</h3>
<div class="level3">

<p>
A large bunch of tools over the Internet exists in order to let you do <abbr title="Operating System">OS</abbr> fingerprinting, we will show here an example using <em>nmap</em>:
</p>
<div class="table sectionedit4"><table class="inline">
	<tr class="row0">
		<td class="col0"> <code>nmap -P0 -O <em>IP address</em>
Starting Nmap 4.20 ( <a href="http://insecure.org" class="urlextern" title="http://insecure.org"  rel="nofollow">http://insecure.org</a> ) at 2007-01-08 11:05 CET
Interesting ports on 192.168.2.1:
Not shown: 1693 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
23/tcp open  telnet
53/tcp open  domain
80/tcp open  http
MAC Address: 00:13:xx:xx:xx:xx (Cisco-Linksys)
Device type: broadband router
Running: Linksys embedded
<abbr title="Operating System">OS</abbr> details: Linksys WRT54GS v4 running OpenWrt w/Linux kernel 2.4.30
Network Distance: 1 hop</code> </td>
	</tr>
</table></div>

<p>
The <em>nmap</em> utility is able to report whether your device uses a Linux TCP/IP stack, and if so, will show you which Linux kernel
version is probably runs. This report is quite reliable and it can make the distinction between BSD and Linux TCP/IP stacks and others.
</p>

<p>
Using the same tool, you can also do port scanning and service version discovery. For instance, the following command will report which
IP-based services are running on the device, and which version of the service is being used:
</p>
<div class="table sectionedit5"><table class="inline">
	<tr class="row0">
		<td class="col0"> <code>nmap -P0 -sV <em>IP address</em>
Starting Nmap 4.20 ( <a href="http://insecure.org" class="urlextern" title="http://insecure.org"  rel="nofollow">http://insecure.org</a> ) at 2007-01-08 11:06 CET  
Interesting ports on 192.168.2.1:  
Not shown: 1693 closed ports  
PORT   STATE SERVICE VERSION  
22/tcp open  ssh     Dropbear sshd 0.48 (protocol 2.0)  
23/tcp open  telnet  Busybox telnetd  
53/tcp open  domain  ISC Bind dnsmasq-2.35  
80/tcp open  http    OpenWrt BusyBox httpd  
MAC Address: 00:13:xx:xx:xx:xx (Cisco-Linksys)  
Service Info: Device: WAP</code> </td>
	</tr>
</table></div>

<p>
The web server version, if identified, can be determining in knowing the Operating System. For instance, the BOA web server is typical
from devices running an open-source Unix or Unix-like.
</p>

</div>

<h3 class="sectionedit6" id="wireless_communications_fingerprinting">Wireless Communications Fingerprinting</h3>
<div class="level3">

<p>
Although this method is not really known and widespread, using a wireless scanner to discover which <abbr title="Operating System">OS</abbr> your router or Access Point
run can be used. We do not have a clear example of how this could be achieved, but you will have to monitor raw 802.11 frames and
compare them to a very similar device running a Linux based firmware.
</p>

</div>

<h3 class="sectionedit7" id="web_server_security_exploits">Web server security exploits</h3>
<div class="level3">

<p>
The Linksys WRT54G was originally hacked by using a &quot;ping bug&quot; discovered in the web interface. This tip has not been fixed for
months by Linksys, allowing people to enable the &quot;boot_wait&quot; helper process via the web interface. Many web servers used in firmwares
are open source web server, thus allowing the code to be audited to find an exploit. Once you know the web server version that runs on
your device, by using nmap -sV or so, you might be interested in using exploits to reach shell access on your device.
</p>

</div>

<h3 class="sectionedit8" id="native_telnetssh_access">Native Telnet/SSH access</h3>
<div class="level3">

<p>
Some firmwares might have restricted or unrestricted Telnet/SSH access, if so, try to log in with the web interface login/password
and see if you can type in some commands. This is actually the case for some Broadcom BCM963xx based firmwares such as the one in
Neuf/Cegetel ISP routers, Club-Internet ISP CI-Box and many others. Some commands, like cat might be left here and be used to
determine the Linux kernel version.
</p>

</div>

<h3 class="sectionedit9" id="analyzing_a_binary_firmware_image">Analyzing a binary firmware image</h3>
<div class="level3">

<p>
You are very likely to find a firmware binary image on the manufacturer website, even if your device runs a proprietary operating system.
If so, you can download it and use an hexadecimal editor to find printable words such as vmlinux, linux, ramdisk, mtd and others.
</p>

<p>
Some Unix tools like <code>hexdump</code> or <code>strings</code> can be used to analyze the firmware. Below there is an example with a binary firmware found
on the Internet:
</p>
<div class="table sectionedit10"><table class="inline">
	<tr class="row0">
		<td class="col0"> <code>hexdump -C &lt;binary image.extension&gt; | less 
00000000  46 49 52 45 32 2e 35 2e  30 00 00 00 00 00 00 00  |FIRE2.5.0.......|  
00000010  00 00 00 00 31 2e 30 2e  30 00 00 00 00 00 00 00  |....1.0.0.......|  
00000020  00 00 00 00 00 00 00 38  00 43 36 29 00 0a e6 dc  |.......8.C6)..??|  
00000030  54 49 44 45 92 89 54 66  1f 8b 08 08 f8 10 68 42  |TIDE..Tf....?.hB|  
00000040  02 03 72 61 6d 64 69 73  6b 00 ec 7d 09 bc d5 d3  |..ramdisk.?}.???|  
00000050  da ff f3 9b f7 39 7b ef  73 f6 19 3b 53 67 ea 44  |???.?9{?s?.;Sg?D|</code> </td>
	</tr>
</table></div>

<p>
Scroll over the firmware to find printable words that can be significant.
</p>

</div>

<h3 class="sectionedit11" id="amount_of_flash_memory">Amount of flash memory</h3>
<div class="level3">

<p>
Linux can hardly fit in a 2MB flash device, once you have opened the device and located the flash chip, try to find its characteristics
on the Internet. If your flash chip is a 2MB or less device, your device is most likely to run a proprietary <abbr title="Operating System">OS</abbr> such as WindRiver VxWorks,
or a custom manufacturer <abbr title="Operating System">OS</abbr> like Zyxel ZynOS.
</p>

<p>
OpenWrt does not currently run on devices which have 2MB or less of flash memory. This limitation will probably not be worked around since
those devices are most of the time micro-routers, or Wireless Access Points, which are not the main OpenWrt target.
</p>

</div>

<h3 class="sectionedit12" id="plugging_a_serial_port">Plugging a serial port</h3>
<div class="level3">

<p>
By using a serial port and a level shifter, you may reach the console that is being shown by the device for debugging or flashing purposes.
By analyzing the output of this device, you can easily notice if the device uses a Linux kernel or something different.
</p>

</div>

<h2 class="sectionedit13" id="finding_and_using_the_manufacturer_sdk">Finding and using the manufacturer SDK</h2>
<div class="level2">

<p>
Once you are sure your device run a Linux based firmware, you will be able to start hacking on it. If the manufacturer respected the <abbr title="GNU General Public License">GPL</abbr>,
it will have released a Sample Development Kit with the device.
</p>

</div>

<h3 class="sectionedit14" id="gpl_violations">GPL violations</h3>
<div class="level3">

<p>
Some manufacturers do release a Linux based binary firmware, with no sources at all. The first step before doing anything is to read the
license coming with your device, then write them about this lack of Open Source code. If the manufacturer answers you they do not have
to release a SDK containing Open Source software, then we recommend you get in touch with the gpl-violations.org community.
</p>

<p>
You will find below a sample letter that can be sent to the manufacturer:
</p>
<div class="table sectionedit15"><table class="inline">
	<tr class="row0">
		<td class="col0"> <code>Miss, Mister,

I am using a <em>device name</em>, and I cannot find neither on your website nor on the CD-ROM 
the open source software used to build or modify the firmware.

In conformance to the <abbr title="GNU General Public License">GPL</abbr> license, you have to release the following sources:

 * complete toolchain that made the kernel and applications be compiled (gcc, binutils, libc)
 * tools to build a custom firmware (mksquashfs, mkcramfs …)
 * kernel sources with patches to make it run on this specific hardware, this does not include binary drivers

Thank you very much in advance for your answer.

Best regards, <em>Your Name</em></code> </td>
	</tr>
</table></div>

</div>

<h3 class="sectionedit16" id="using_the_sdk">Using the SDK</h3>
<div class="level3">

<p>
Once the SDK is available, you are most likely not to be able to build a complete or functional firmware using it, but parts of it, like
only the kernel, or only the root filesystem. Most manufacturers do not really care releasing a tool that do work every time you uncompress
and use it.
</p>

<p>
You should anyway be able to use the following components:
</p>
<ul>
<li class="level1"><div class="li"> kernel sources with more or less functional patches for your hardware</div>
</li>
<li class="level1"><div class="li"> binary drivers linked or to be linked with the shipped kernel version</div>
</li>
<li class="level1"><div class="li"> packages of the toolchain used to compile the whole firmware: gcc, binutils, libc or uClibc</div>
</li>
<li class="level1"><div class="li"> binary tools to create a valid firmware image</div>
</li>
</ul>

<p>
Your work can be divided into the following tasks:
</p>
<ul>
<li class="level1"><div class="li"> create a clean patch of the hardware specific part of the Linux kernel</div>
</li>
<li class="level1"><div class="li"> spot potential kernel <abbr title="GNU General Public License">GPL</abbr> violations especially on network stack and USB stack stuff</div>
</li>
<li class="level1"><div class="li"> make the binary drivers work, until there are open source drivers</div>
</li>
<li class="level1"><div class="li"> use standard a GNU toolchain to make working executables</div>
</li>
<li class="level1"><div class="li"> understand and write open source tools to generate a valid firmware image</div>
</li>
</ul>

</div>

<h3 class="sectionedit17" id="creating_a_hardware_specific_kernel_patch">Creating a hardware specific kernel patch</h3>
<div class="level3">

<p>
Most of the time, the kernel source that comes along with the SDK is not really clean, and is not a standard Linux version, it also has
architecture specific fixes backported from the CVS or the git repository of the kernel development trees. Anyway, some parts can be easily
isolated and used as a good start to make a vanilla kernel work your hardware.
</p>

<p>
Some directories are very likely to have local modifications needed to make your hardware be recognized and used under Linux. First of all,
you need to find out the linux kernel version that is used by your hardware, this can be found by editing the linux/Makefile file.
</p>
<div class="table sectionedit18"><table class="inline">
	<tr class="row0">
		<td class="col0"> <code>head -5 linux-2.x.x/Makefile  
VERSION = 2  
PATCHLEVEL = x  
SUBLEVEL = y  
EXTRAVERSION = z  
NAME=A fancy name</code> </td>
	</tr>
</table></div>

<p>
So now, you know that you have to download a standard kernel tarball at kernel.org that matches the version being used by your hardware.
</p>

<p>
Then you can create a diff file between the two trees, especially for the following directories:
</p>
<div class="table sectionedit19"><table class="inline">
	<tr class="row0">
		<td class="col0"> <code>diff -urN linux-2.x.x/arch<em>/sub architecture</em> linux-2.x.x-modified/arch<em>/sub architecture</em> &gt; 01-architecture.patch  
diff -urN linux-2.x.x/include/ linux-2.x.x-modified/include &gt; 02-includes.patch  
diff -urN linux-2.x.x/drivers/ linux-2.x.x-modified/drivers &gt; 03-drivers.patch</code> </td>
	</tr>
</table></div>

<p>
This will constitute a basic set of three patches that are very likely to contain any needed modifications that has been made to the stock
Linux kernel to run on your specific device. Of course, the content produced by the diff -urN may not always be relevant, so that you have
to clean up those patches to only let the &quot;must have&quot; code into them.
</p>

<p>
The first patch will contain all the code that is needed by the board to be initialized at startup, as well as processor detection and other
boot time specific fixes.
</p>

<p>
The second patch will contain all useful definitions for that board: addresses, kernel granularity, redefinitions, processor family and
features …
</p>

<p>
The third patch may contain drivers for: serial console, ethernet NIC, wireless NIC, USB NIC … Most of the time this patch contains nothing
else than &quot;glue&quot; code that has been added to make the binary driver work with the Linux kernel. This code might not be useful if you plan on
writing drivers from scratch for this hardware.
</p>

</div>

<h3 class="sectionedit20" id="using_the_device_bootloader">Using the device bootloader</h3>
<div class="level3">

<p>
The <a href="../techref/bootloader.1" class="wikilink1" title="doc:techref:bootloader">bootloader</a> is the first program that is started right after your device has been powered on. This program, can be more or less sophisticated,
some do let you do network booting, USB mass storage booting … The bootloader is device and architecture specific, some bootloaders were
designed to be universal such as RedBoot or <a href="../techref/bootloader/uboot" class="wikilink1" title="doc:techref:bootloader:uboot">Das U-Boot</a> so that you can meet those loaders on totally different platforms and expect them to behave the same way.
</p>

<p>
If your device runs a proprietary operating system, you are very likely to deal with a proprietary boot loader as well. This may not always be a
limitation, some proprietary bootloaders can even have source code available (i.e : Broadcom CFE).
</p>

<p>
According to the bootloader features, hacking on the device will be more or less easier. It is very probable that the bootloader, even exotic and rare, has a documentation somewhere over the Internet. In order to know what will be possible with your bootloader and the way you are going to hack the device, look over the following features:
</p>
<ul>
<li class="level1"><div class="li"> does the bootloader allow <a href="../../inbox/netboot" class="wikilink1" title="inbox:netboot">net booting</a> via <a href="http://en.wikipedia.org/wiki/Bootstrap Protocol" class="interwiki iw_wp" title="http://en.wikipedia.org/wiki/Bootstrap Protocol">BOOTP</a>/<a href="http://en.wikipedia.org/wiki/Preboot Execution Environment" class="interwiki iw_wp" title="http://en.wikipedia.org/wiki/Preboot Execution Environment">PXE</a>/DHCP/NFS or <a href="http://en.wikipedia.org/wiki/Trivial File Transfer Protocol" class="interwiki iw_wp" title="http://en.wikipedia.org/wiki/Trivial File Transfer Protocol">TFTP</a>?</div>
</li>
<li class="level1"><div class="li"> does the bootloader accept loading <a href="http://en.wikipedia.org/wiki/Executable and Linkable Format" class="interwiki iw_wp" title="http://en.wikipedia.org/wiki/Executable and Linkable Format">ELF</a> binaries?</div>
</li>
<li class="level1"><div class="li"> does the bootloader have a kernel/firmware size limitation?</div>
</li>
<li class="level1"><div class="li"> does the bootloader expect some magic values to be part of the firmware, or the firmware to be encrypted?</div>
</li>
<li class="level1"><div class="li"> does the bootloader expect a firmware format to be loaded with?</div>
</li>
<li class="level1"><div class="li"> are the loaded files executed from RAM or flash?</div>
</li>
</ul>

<p>
Net booting is something very convenient, because you will only have to set up network booting servers on your development station, and keep the
original firmware on the device till you are sure you can replace it. This also prevents your device from being flashed, and potentially bricked
every time you want to test a modification on the kernel/filesystem.
</p>

<p>
If your device needs to be flashed every time you load a firmware, the bootlader might only accept a specific firmware format to be loaded, so
that you will have to understand the firmware format as well.
</p>

</div>

<h3 class="sectionedit21" id="making_binary_drivers_work">Making binary drivers work</h3>
<div class="level3">

<p>
As we have explained before, manufacturers do release binary drivers in their <abbr title="GNU General Public License">GPL</abbr> tarball. When those drivers are statically linked into the
kernel, they become <abbr title="GNU General Public License">GPL</abbr> as well, fortunately or unfortunately, most of the drivers are not statically linked. This anyway lets you a chance to
dynamically link the driver with the current kernel version, and try to make them work together.
</p>

<p>
This is one of the most tricky and grey part of the fully open source projects. Some drivers require few modifications to be working with your
custom kernel, because they worked with an earlier kernel, and few modifications have been made to the kernel in-between those versions.
This is for instance the case with the binary driver of the Broadcom BCM43xx Wireless Chipsets, where only few differences were made to the
network interface structures.
</p>

<p>
Some general principles can be applied no matter which kernel version is used in order to make binary drivers work with your custom kernel:
</p>
<ul>
<li class="level1"><div class="li"> turn on kernel debugging features such as:</div>
<ul>
<li class="level2"><div class="li"> CONFIG_DEBUG_KERNEL</div>
</li>
<li class="level2"><div class="li"> CONFIG_DETECT_SOFTLOCKUP</div>
</li>
<li class="level2"><div class="li"> CONFIG_DEBUG_KOBJECT</div>
</li>
<li class="level2"><div class="li"> CONFIG_KALLSYMS</div>
</li>
<li class="level2"><div class="li"> CONFIG_KALLSYMS_ALL</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> link binary drivers when possible to the current kernel version</div>
</li>
<li class="level1"><div class="li"> try to load those binary drivers</div>
</li>
<li class="level1"><div class="li"> catch the lockups and understand them</div>
</li>
</ul>

<p>
Most of the time, loading binary drivers will fail, and generate a kernel oops. You can know the last symbol the binary drivers attempted to
use, and see in the kernel headers file, if you do not have to move some structures field before or after that symbol in order to keep compatibily
with both the binary driver and the stock kernel drivers.
</p>

</div>

<h3 class="sectionedit22" id="understanding_the_firmware_format">Understanding the firmware format</h3>
<div class="level3">

<p>
You might want to understand the firmware format, even if you are not yet capable of running a custom firmware on your device, because this is
sometimes a blocking part of the flashing process.
</p>

<p>
A firmware format is most of the time composed of the following fields:
</p>
<ul>
<li class="level1"><div class="li"> header, containing a firmware version and additional fields: Vendor, Hardware version …</div>
</li>
<li class="level1"><div class="li"> CRC32 checksum on either the whole file or just part of it</div>
</li>
<li class="level1"><div class="li"> Binary and/or compressed kernel image</div>
</li>
<li class="level1"><div class="li"> Binary and/or compressed root filesystem image</div>
</li>
<li class="level1"><div class="li"> potential garbage</div>
</li>
</ul>

<p>
Once you have figured out how the firmware format is partitioned, you will have to write your own tool that produces valid firmware binaries.
One thing to be very careful here is the endianness of either the machine that produces the binary firmware and the device that will be flashed
using this binary firmware.
</p>

</div>

<h3 class="sectionedit23" id="writing_a_flash_map_driver">Writing a flash map driver</h3>
<div class="level3">

<p>
The flash map driver has an important role in making your custom firmware work because it is responsible of mapping the correct flash regions and
associated rights to specific parts of the system such as: bootloader, kernel, user filesystem.
</p>

<p>
Writing your own flash map driver is not really a hard task once you know how your firmware image and flash is structured. You will find below a
commented example that covers the case of the device where the bootloader can pass to the kernel its partition plan.
</p>

<p>
First of all, you need to make your flash map driver be visible in the kernel configuration options, this can be done by editing the file
<code>linux/drivers/mtd/maps/Kconfig</code>:
</p>
<div class="table sectionedit24"><table class="inline">
	<tr class="row0">
		<td class="col0"> <code>config MTD_DEVICE_FLASH  
        tristate &quot;Device Flash device&quot;  
        depends on ARCHITECTURE &amp;&amp; DEVICE  
        help  
         Flash memory access on DEVICE boards. Currently only works with  
         Bootloader Foo and Bootloader Bar.</code> </td>
	</tr>
</table></div>

<p>
Then add your source file to the linux/drivers/mtd/maps/Makefile, so that it will be compiled along with the kernel.
</p>
<div class="table sectionedit25"><table class="inline">
	<tr class="row0">
		<td class="col0"> <code>obj-$(CONFIG_MTD_DEVICE_FLASH)      += device-flash.o</code> </td>
	</tr>
</table></div>

<p>
You can then write the kernel driver itself, by creating a <code>linux/drivers/mtd/maps/device-flash.c</code> C source file.
</p>
<div class="table sectionedit26"><table class="inline">
	<tr class="row0">
		<td class="col0"> <pre class="code c"><span class="co1">// Includes that are required for the flash map driver to know of the prototypes:  </span>
<span class="co2">#include &lt;asm/io.h&gt;</span>
<span class="co2">#include &lt;linux/init.h&gt;</span>
<span class="co2">#include &lt;linux/kernel.h&gt;</span>
<span class="co2">#include &lt;linux/mtd/map.h&gt;</span>
<span class="co2">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="co2">#include &lt;linux/mtd/partitions.h&gt;</span>
<span class="co2">#include &lt;linux/vmalloc.h&gt;</span>
&nbsp;
<span class="co1">// Put some flash map definitions here:  </span>
<span class="co2">#define WINDOW_ADDR 0x1FC00000	/* Real address of the flash */</span>
<span class="co2">#define WINDOW_SIZE 0x400000	/* Size of flash */</span>
<span class="co2">#define BUSWIDTH 2		/* Buswidth */</span>
&nbsp;
<span class="kw4">static</span> <span class="kw4">void</span> __exit device_mtd_cleanup<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">static</span> <span class="kw4">struct</span> mtd_info <span class="sy0">*</span>device_mtd_info<span class="sy0">;</span>
&nbsp;
<span class="kw4">static</span> <span class="kw4">struct</span> map_info devicd_map <span class="sy0">=</span> <span class="br0">&#123;</span>
	.<span class="me1">name</span> <span class="sy0">=</span> <span class="st0">&quot;device&quot;</span><span class="sy0">,</span>
	.<span class="me1">size</span> <span class="sy0">=</span> WINDOW_SIZE<span class="sy0">,</span>
	.<span class="me1">bankwidth</span> <span class="sy0">=</span> BUSWIDTH<span class="sy0">,</span>
	.<span class="me1">phys</span> <span class="sy0">=</span> WINDOW_ADDR<span class="sy0">,</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">static</span> <span class="kw4">int</span> __init device_mtd_init<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="co1">// Display that we found a flash map device  </span>
	printk<span class="br0">&#40;</span><span class="st0">&quot;device: 0x\%08x at 0x\%08x<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> WINDOW_SIZE<span class="sy0">,</span> WINDOW_ADDR<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="co1">// Remap the device address to a kernel address  </span>
	device_map.<span class="me1">virt</span> <span class="sy0">=</span> ioremap<span class="br0">&#40;</span>WINDOW_ADDR<span class="sy0">,</span> WINDOW_SIZE<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="co1">// If impossible to remap, exit with the EIO error  </span>
	<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span>device_map.<span class="me1">virt</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		printk<span class="br0">&#40;</span><span class="st0">&quot;device: Failed to ioremap<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">return</span> <span class="sy0">-</span>EIO<span class="sy0">;</span>
	<span class="br0">&#125;</span>
	<span class="co1">// Initialize the device map  </span>
	simple_map_init<span class="br0">&#40;</span><span class="sy0">&amp;</span>device_map<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* MTD informations are closely linked to the flash map device  
	   you might also use &quot;jedec_probe&quot; &quot;amd_probe&quot; or &quot;intel_probe&quot; */</span>
	device_mtd_info <span class="sy0">=</span> do_map_probe<span class="br0">&#40;</span><span class="st0">&quot;cfi_probe&quot;</span><span class="sy0">,</span> <span class="sy0">&amp;</span>device_map<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">&#40;</span>device_mtd_info<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		device_mtd_info<span class="sy0">-&gt;</span>owner <span class="sy0">=</span> THIS_MODULE<span class="sy0">;</span>
&nbsp;
		<span class="kw4">int</span> parsed_nr_parts <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// We try here to use the partition schema provided by the bootloader specific code  </span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>parsed_nr_parts <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> ret <span class="sy0">=</span>
			    parse_bootloader_partitions<span class="br0">&#40;</span>device_mtd_info<span class="sy0">,</span>
							<span class="sy0">&amp;</span>parsed_parts<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>ret <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				part_type <span class="sy0">=</span> <span class="st0">&quot;BootLoader&quot;</span><span class="sy0">;</span>
				parsed_nr_parts <span class="sy0">=</span> ret<span class="sy0">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
&nbsp;
		add_mtd_partitions<span class="br0">&#40;</span>devicd_mtd_info<span class="sy0">,</span> parsed_parts<span class="sy0">,</span>
				   parsed_nr_parts<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
	iounmap<span class="br0">&#40;</span>device_map.<span class="me1">virt</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="sy0">-</span>ENXIO<span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="co1">// This function will make the driver clean up the MTD device mapping  </span>
<span class="kw4">static</span> <span class="kw4">void</span> __exit device_mtd_cleanup<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
	<span class="co1">// If we found a MTD device before  </span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>device_mtd_info<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="co1">// Delete every partitions  </span>
		del_mtd_partitions<span class="br0">&#40;</span>device_mtd_info<span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="co1">// Delete the associated map  </span>
		map_destroy<span class="br0">&#40;</span>device_mtd_info<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="co1">// If the virtual address is already in use  </span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>device_map.<span class="me1">virt</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="co1">// Unmap the physical address to a kernel space address  </span>
		iounmap<span class="br0">&#40;</span>device_map.<span class="me1">virt</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Reset the structure field  </span>
		device_map.<span class="me1">virt</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="co1">// Macros that indicate which function is called on loading/unloading the module  </span>
module_init<span class="br0">&#40;</span>device_mtd_init<span class="br0">&#41;</span><span class="sy0">;</span>
module_exit<span class="br0">&#40;</span>device_mtd_cleanup<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// Macros defining license and author, parameters can be defined here too.  </span>
MODULE_LICENSE<span class="br0">&#40;</span><span class="st0">&quot;GPL&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
MODULE_AUTHOR<span class="br0">&#40;</span><span class="st0">&quot;Me, myself and I &lt;memyselfandi@domain.tld&gt;&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
 </td>
	</tr>
</table></div>

</div>

                    <!-- wikipage stop -->
                                    </div>

                <div class="docInfo"><bdi>doc/devel/add.new.platform.txt</bdi> · Last modified: 2011/04/04 17:03 by <bdi>orca</bdi></div>

                            </div></div><!-- /content -->

            <hr class="a11y" />

            <!-- PAGE ACTIONS -->
            <div id="dokuwiki__pagetools">
                <h3 class="a11y">Page Tools</h3>
                <div class="tools">
                    <ul>
                        <li><a href="add.new.platform?do=edit"  class="action source" accesskey="v" rel="nofollow" title="Show pagesource [V]"><span>Show pagesource</span></a></li><li><a href="add.new.platform?do=revisions"  class="action revs" accesskey="o" rel="nofollow" title="Old revisions [O]"><span>Old revisions</span></a></li><li><a href="add.new.platform?do=backlink"  class="action backlink" rel="nofollow" title="Backlinks"><span>Backlinks</span></a></li><li><a href="add.new.platform#dokuwiki__top"  class="action top" accesskey="t" rel="nofollow" title="Back to top [T]"><span>Back to top</span></a></li>                    </ul>
                </div>
            </div>
        </div><!-- /wrapper -->

        
<!-- ********** FOOTER ********** -->
<div id="dokuwiki__footer"><div class="pad">
    <div class="license">Except where otherwise noted, content on this wiki is licensed under the following license: <bdi><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="license" class="urlextern">CC Attribution-Noncommercial-Share Alike 3.0 Unported</a></bdi></div>
    <div class="buttons">
        <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="license"><img src="../../lib/images/license/button/cc-by-nc-sa.png" alt="CC Attribution-Noncommercial-Share Alike 3.0 Unported" /></a>        <a href="http://www.dokuwiki.org/donate" title="Donate" ><img
            src="../../lib/tpl/openwrt/images/button-donate.gif" width="80" height="15" alt="Donate" /></a>
        <a href="http://www.php.net" title="Powered by PHP" ><img
            src="../../lib/tpl/openwrt/images/button-php.gif" width="80" height="15" alt="Powered by PHP" /></a>
        <a href="http://validator.w3.org/check/referer" title="Valid HTML5" ><img
            src="../../lib/tpl/openwrt/images/button-html5.png" width="80" height="15" alt="Valid HTML5" /></a>
        <a href="http://jigsaw.w3.org/css-validator/check/referer?profile=css3" title="Valid CSS" ><img
            src="../../lib/tpl/openwrt/images/button-css.png" width="80" height="15" alt="Valid CSS" /></a>
        <a href="http://dokuwiki.org/" title="Driven by DokuWiki" ><img
            src="../../lib/tpl/openwrt/images/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" /></a>
    </div>
</div></div><!-- /footer -->

    </div></div><!-- /site -->

    <div class="no"><img src="../../lib/exe/indexer.php?id=doc%253Adevel%253Aadd.new.platform&amp;1432265700" width="2" height="1" alt="" /></div>
    <div id="screen__mode" class="no"></div>    <!--[if ( lte IE 7 | IE 8 ) ]></div><![endif]-->
</body>
</html>
